const = require("const")
graphics = require("graphics")
bodies = require("bodies")
misc = require("misc")

local snake = {}

snake.LENGTH = 5

snake.idleStraightSpriteSheet = graphics.SpriteSheet:new("snakeIdleStraight.png", 5)
snake.moveStraightSpriteSheets = {}
for i = 1, 6 do
  snake.moveStraightSpriteSheets[i] = graphics.SpriteSheet:new("snake"..i.."MoveStraight.png", 7)
end

snake.idleClockwiseSpriteSheet = graphics.SpriteSheet:new("snakeIdleClockwise.png", 3)
snake.moveClockwiseSpriteSheets = {}

snake.idleCounterClockwiseSpriteSheet = graphics.SpriteSheet:new("snakeIdleCounterClockwise.png", 3)
snake.moveCounterClockwiseSpriteSheets = {}
for i = 1, 4 do
  snake.moveClockwiseSpriteSheets[i] = graphics.SpriteSheet:new("snake"..i.."MoveClockwise.png", 7)
  snake.moveCounterClockwiseSpriteSheets[i] = graphics.SpriteSheet:new("snake"..i.."MoveCounterClockwise.png", 7)
end

snake.tailWaggle1SpriteSheet = graphics.SpriteSheet:new("snakeTailWaggle1.png", 8)
snake.tailWaggle2SpriteSheet = graphics.SpriteSheet:new("snakeTailWaggle2.png", 5)


snake.Snake = {}

--- Constructor.  Makes a snake enemy.
-- The snake enemy consists of 5 segments.
-- The enemy always waits two turns, then moves closer to the player.
function snake.Snake:new(spaceList, directionList)
  
  local newObj = {
    moveTimer = 0,
    
    tailAnimation = nil,
    idleAnim1 = graphics.Animation:new(snake.tailWaggle1SpriteSheet),
    idleAnim2 = graphics.Animation:new(snake.tailWaggle2SpriteSheet),
    
    moveStraightAnims = {},
    moveClockwiseAnims = {},
    moveCounterClockwiseAnims = {},
    
    bodyList = {},
    
    -- Stores direction of tail before a movement, so that during the movement it can be drawn properly
    previousTailDirection = nil
  }
  
  newObj.idleAnim1:setFrameLength(6)
  newObj.idleAnim2:setFrameLength(4)
  
  -- Creates all the bodies, and initializes the straight-movement animations
  for i = 1, snake.LENGTH do
    newObj.bodyList[i] = bodies.WarpBody:new(spaceList[i])
    newObj.bodyList[i].flyCount = 1
    
    newObj.moveStraightAnims[i] = graphics.Animation:new(snake.moveStraightSpriteSheets[i])
    newObj.moveStraightAnims[i]:setFrameLength(3)
  end
  
  -- Initializes the last straight-movement animation
  local lastAnim = graphics.Animation:new(snake.moveStraightSpriteSheets[snake.LENGTH + 1])
  newObj.moveStraightAnims[snake.LENGTH + 1] = lastAnim
  newObj.moveStraightAnims[snake.LENGTH + 1]:setFrameLength(3)
  
  -- Initializes the curved movement animations
  for i = 1, snake.LENGTH - 1 do
    newObj.moveClockwiseAnims[i] = graphics.Animation:new(snake.moveClockwiseSpriteSheets[i])
    newObj.moveClockwiseAnims[i]:setFrameLength(3)
    newObj.moveCounterClockwiseAnims[i] = graphics.Animation:new(snake.moveCounterClockwiseSpriteSheets[i])
    newObj.moveCounterClockwiseAnims[i]:setFrameLength(3)
  end

  
  for i = 1, snake.LENGTH do
    newObj.bodyList[i].moveDirection = directionList[i]
  end
  
  -- Determines the initial direction of all the parts
  -- Old, autogenerated directions sometimes generate u-turns, which are invalid
  --[[
  local previousBody
  local currentBody

  for i = 2, snake.LENGTH do
    previousBody = newObj.bodyList[i - 1]
    currentBody = newObj.bodyList[i]

    previousBody.moveDirection = currentBody.space:directionOf(previousBody.space)
  end
  newObj.bodyList[snake.LENGTH].moveDirection = newObj.bodyList[snake.LENGTH - 1].moveDirection
  ]]
  
  self.__index = self
  return setmetatable(newObj, self)
end


--- Constructor.  Makes a snake enemy, with random spaces spreading out from a starting location.
-- Returns nil if a valid snake could not be generated.
function snake.Snake:newRandom(startSpace)
  if startSpace:isOccupied() then
    return nil
  end
  
  local spaceList
  
  local checkSpace
  local isValidSpace = false
  
  local fullRerolls = 0
  local snakeIsValid = false
  local spaceRerolls
  local spaceFound = false
  
  local adjacentLength
  
  local spaceOccupied
  
  local checkDirection
  local validDirections = {}
  local invalidDirection
  
  local directionList = {}
  
  -- Loops until a valid snake is returned
  while true do
    
    -- If 25 full-snake rerolls occur, then a valid snake could not be generated.
    if fullRerolls > 25 then
      print("Could not generate a snake here!")
      return nil
    else
      -- The snake is valid, until proven otherwise
      snakeIsValid = true
      fullRerolls = fullRerolls + 1
      
      invalidDirection = nil
    end
    
    -- Generates all the body sections (except the first, since that's the startSpace)
    spaceList = {startSpace}
    for i = 2, snake.LENGTH do
      
      -- Determines all valid directions the snake should spawn in.
      -- On the first loop, all directions are valid.
      validDirections = {}
      for j = 1, #const.DIRECTIONS do
        if const.DIRECTIONS[j] ~= invalidDirection then
          validDirections[const.DIRECTIONS[j]] = true
        end
      end
      
      -- Loops until a valid space for the next part of the snake is found
      spaceRerolls = 0
      isValidSpace = false
      while not isValidSpace do
        
        -- If 25 rerolls occur, then the snake probably trapped itself during generation.
        if spaceRerolls > 25 then
          spaceFound = false
          break
        else
          -- The space is valid, until proven otherwise
          isValidSpace = true
          spaceFound = true
          spaceRerolls = spaceRerolls + 1
        end
        
        -- Randomly chooses one of the adjacent spaces
        checkDirection = misc.randomChoice(validDirections)
        checkSpace = misc.randomChoice(spaceList[i - 1].adjacent[checkDirection])
        
        -- If there are no adjacent spaces in that direction, randomChoice returns nil
        if not checkSpace then
          isValidSpace = false
          
        else
        
          -- Checks if anything is on the space
          if checkSpace:isOccupied() then
            isValidSpace = false
          end
          
          -- Checks if the space is the same as a previous space
          for j = 1, i - 1 do
            if checkSpace == spaceList[j] then
              isValidSpace = false
              break
            end
          end
          
        end
        
      end
      
      -- If one of the spaces could not be found, reroll the whole snake
      if not spaceFound then
        snakeIsValid = false
        break
        
      -- Otherwise, set this space as the next space in the list
      else
        spaceList[i] = checkSpace
        invalidDirection = misc.oppositeOf(checkDirection)
        directionList[i - 1] = invalidDirection
        
      end
      
    end
    
    -- If all the spaces were generated validly
    if snakeIsValid then
      
      -- Check that the snake didn't trap itself
      for space, _ in pairs(spaceList[1].adjacentList) do
        spaceOccupied = false
        
        for i = 1, snake.LENGTH do
          if space == spaceList[i] then
            spaceOccupied = true
          end
        end
        
        -- Return the snake if it has at least one space to move to
        if not spaceOccupied then
          directionList[snake.LENGTH] = directionList[snake.LENGTH - 1]
          return self:new(spaceList, directionList)
        end
        
      end
      
      -- If not, then reroll
    end
    
    -- Otherwise, go back to the start of the while loop and reroll the entire snake.
    
  end
end


--- Makes the snake move.
-- The head of the snake always moves one step closer to the player.
-- The rest of the parts follow the part before it.
function snake.Snake:move(player)
  local closestSpace
  local closestSpaceDirection
  
  local direction
  local previousSpace
  local nextSpace
  local previousDirection
  local nextDirection
  
  -- Rerolls the space until the snake isn't moving backwards
  for i = 1, 25 do
    
    closestSpace = self.bodyList[1].space:closestAdjacent(player)
    closestSpaceDirection = self.bodyList[1].space:directionOf(closestSpace)
    
    if self.bodyList[1].moveDirection == misc.oppositeOf(closestSpaceDirection) then
      closestSpace = nil
    else
      break
    end
    
  end
  
  if closestSpace then
    
    self.previousTailDirection = self.bodyList[snake.LENGTH].moveDirection
    
    -- For each snake part, move to the next space.
    -- The next space for the head is the closest adjacent space to the player.
    -- The next space for all the other parts is the pre-movement space of the previous part.
    -- Note that the tail always takes the direction of the previous part.
    local body
    nextSpace = closestSpace
    nextDirection = self.bodyList[1].space:directionOf(nextSpace)
    for i = 1, snake.LENGTH do
      body = self.bodyList[i]
      
      previousSpace = body.space
      previousDirection = body.moveDirection

      body:moveTo(nextSpace, nextDirection)
      
      nextSpace = previousSpace
      nextDirection = previousDirection
    end
    
  -- If no valid space was found then
  else
    -- Play the "can't move" animation
  end
    
end


--- Makes the snake take a turn.
-- Snakes always wait two turns, then move closer to the player.
function snake.Snake:takeTurn(level, player)
  self.moveTimer = self.moveTimer + 1
  
  -- Updates tail waggle animations
  if self.moveTimer == 1 then
    self.idleAnim1:reset()
    self.tailAnimation = self.idleAnim1
    
  elseif self.moveTimer == 2 then
    self.idleAnim2:reset()
    self.tailAnimation = self.idleAnim2
    
  -- Makes the snake move
  elseif self.moveTimer == 3 then
    
    -- If the snake is beside the player, hurt them
    if self.bodyList[1].space.distanceFromPlayer == 1 then
      
    -- Otherwise, just move normally
    else
      self:move(player)
    end
    
    self.moveTimer = 0
  end
end


--- Draws one part of the snake's body, in its idle state.
function snake.Snake:drawIdle(bodyNum, gridXOffset, gridYOffset, scale, tileSize)
  local x
  local y
  local rotation
  
  local spriteSheet
  local spriteNum
  
  -- Head is always drawn straight
  if bodyNum == 1 then
    spriteSheet = snake.idleStraightSpriteSheet
    spriteNum = bodyNum
    
  elseif bodyNum == snake.LENGTH then
    
    -- Draws tail wagging animation
    if self.moveTimer == 1 or self.moveTimer == 2 then
      rotation = misc.rotationOf(self.bodyList[bodyNum].moveDirection)
  
      for colNum, col in pairs(self.bodyList[bodyNum].space.cells) do
        for rowNum, _ in pairs(col) do
          x = gridXOffset + ((colNum - 1) * tileSize)
          y = gridYOffset + ((rowNum - 1) * tileSize)
          
          self.tailAnimation:draw(x, y, scale, rotation)
        end
      end
      
      return
    end
    
    -- Otherwise, sets up the tail to be drawn normally
    spriteSheet = snake.idleStraightSpriteSheet
    spriteNum = bodyNum
    
  else
    local currentDirection = self.bodyList[bodyNum].moveDirection
    local previousDirection = self.bodyList[bodyNum - 1].moveDirection
    
    -- If both body parts came from the same direction, then the body part is straight
    if previousDirection == currentDirection then
      spriteSheet = snake.idleStraightSpriteSheet
      spriteNum = bodyNum
      
    -- From right (currentDirection == left) going up (previousDirection == up)
    elseif previousDirection == misc.counterClockwiseTo(currentDirection) then
      spriteSheet = snake.idleCounterClockwiseSpriteSheet
      spriteNum = bodyNum - 1
      
    -- From left (currentDirection == right) going up (previousDirection == down)
    elseif previousDirection == misc.clockwiseTo(currentDirection) then
      spriteSheet = snake.idleClockwiseSpriteSheet
      spriteNum = bodyNum - 1
    
    else
      error("This shouldn't happen?  Current direction and previous direction are opposite.")
    end
  end
  
  rotation = misc.rotationOf(self.bodyList[bodyNum].moveDirection)
  
  for colNum, col in pairs(self.bodyList[bodyNum].space.cells) do
    for rowNum, _ in pairs(col) do
      x = gridXOffset + ((colNum - 1) * tileSize)
      y = gridYOffset + ((rowNum - 1) * tileSize)
      
      spriteSheet:draw(spriteNum, x, y, scale, rotation)
    end
  end
end


-- Draws one part of the snake's body, in its moving state.
-- This splits the snake into six parts - the first part is the head's new space,
-- and the last part is the tail's old space
function snake.Snake:drawMoving(bodyNum, gridXOffset, gridYOffset, scale, tileSize)
  local x
  local y
  local rotation
  
  local animation
  
  -- New head and old tail are always drawn straight
  if bodyNum == 1 or bodyNum == snake.LENGTH + 1 then
    animation = self.moveStraightAnims[bodyNum]
    
  else
    local currentDirection = self.bodyList[bodyNum].moveDirection
    local previousDirection = self.bodyList[bodyNum - 1].moveDirection
    
    -- If both body parts are moving in the same direction, then the body part is straight
    if previousDirection == currentDirection then
      animation = self.moveStraightAnims[bodyNum]
      
    -- From right (currentDirection == left) going up (previousDirection == up)
    elseif previousDirection == misc.counterClockwiseTo(currentDirection) then
      animation = self.moveCounterClockwiseAnims[bodyNum - 1]
      
    -- From left (currentDirection == right) going up (previousDirection == down)
    elseif previousDirection == misc.clockwiseTo(currentDirection) then
      animation = self.moveClockwiseAnims[bodyNum - 1]
      
    end
  end
  
  local cells
  if bodyNum == snake.LENGTH + 1 then
    cells = self.bodyList[snake.LENGTH].previousSpace.cells
    rotation = misc.rotationOf(self.previousTailDirection)
  else
    cells = self.bodyList[bodyNum].space.cells
    rotation = misc.rotationOf(self.bodyList[bodyNum].moveDirection)
  end
  
  for colNum, col in pairs(cells) do
    for rowNum, _ in pairs(col) do
      x = gridXOffset + ((colNum - 1) * tileSize)
      y = gridYOffset + ((rowNum - 1) * tileSize)
        
      animation:draw(x, y, scale, rotation)
    end
  end
end
    

--- Draws the snake.
function snake.Snake:draw(gridXOffset, gridYOffset, scale, tileSize)
  local rotation
  local color
  
  if self.bodyList[1].moving then

    for i = 1, snake.LENGTH + 1 do
      self:drawMoving(i, gridXOffset, gridYOffset, scale, tileSize)
    end
    
  else
    
    for i = 1, snake.LENGTH do
      self:drawIdle(i, gridXOffset, gridYOffset, scale, tileSize)
    end
    
  end
  
end


--- Updates the snake's animation.  Should be called every frame.
function snake.Snake:updateAnimation()
  if self.bodyList[1].moving then
    for i = 1, snake.LENGTH + 1 do
      self.moveStraightAnims[i]:update()
    end
    
    for i = 1, snake.LENGTH - 1 do
      self.moveClockwiseAnims[i]:update()
      self.moveCounterClockwiseAnims[i]:update()
    end
  
  -- Tail waggle animations
  elseif self.moveTimer == 1 or self.moveTimer == 2 then
    self.tailAnimation:update()
    
    if self.tailAnimation.isDone then
      self.tailAnimation:reset()
    end
  end
  
  if self.moveStraightAnims[1].isDone then
    for i = 1, snake.LENGTH do
      self.bodyList[i].moving = false
      self.moveStraightAnims[i]:reset()
    end
    
    self.moveStraightAnims[snake.LENGTH + 1]:reset()
    
    for i = 1, snake.LENGTH - 1 do
      self.moveClockwiseAnims[i]:reset()
      self.moveCounterClockwiseAnims[i]:reset()
    end
    
    -- Update's the tail's direction, as it faces a different direction during
    -- the animation
    self.bodyList[snake.LENGTH].moveDirection = self.bodyList[snake.LENGTH - 1].moveDirection
  end
end


return snake